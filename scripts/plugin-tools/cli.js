#!/usr/bin/env node

/**
 * Plugin Development CLI Tool
 * Provides commands for plugin development, testing, and management
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Get PrismaClient - in test environments, we'll inject it via a global variable
let PrismaClient;
if (global.mockedPrismaClient) {
  PrismaClient = global.mockedPrismaClient;
} else {
  PrismaClient = require('@prisma/client').PrismaClient;
}

class PluginCLI {
  constructor(prismaClient = null) {
    // Allow injection of Prisma client for testing
    if (prismaClient) {
      this.prisma = prismaClient;
    } else {
      try {
        this.prisma = new PrismaClient();
      } catch (error) {
        console.warn('Failed to create Prisma client:', error.message);
        // Create a minimal mock for testing purposes
        this.prisma = {
          plugin: {
            findUnique: () => Promise.resolve(null),
            findFirst: () => Promise.resolve(null),
            create: (args) => Promise.resolve(args.data),
            update: () => Promise.resolve(),
            delete: () => Promise.resolve(),
            findMany: () => Promise.resolve([])
          },
          pluginData: {
            findUnique: () => Promise.resolve(null),
            findFirst: () => Promise.resolve(null),
            create: (args) => Promise.resolve(args.data),
            update: () => Promise.resolve(),
            delete: () => Promise.resolve(),
            findMany: () => Promise.resolve([])
          }
        };
      }
    }
    this.pluginsDir = path.join(process.cwd(), 'plugins');
    this.samplePluginsDir = path.join(process.cwd(), 'sample-plugins');
  }

  async init() {
    // Ensure plugins directory exists
    if (!fs.existsSync(this.pluginsDir)) {
      fs.mkdirSync(this.pluginsDir, { recursive: true });
    }
  }

  // Create a new plugin from template
  async create(pluginName) {
    console.log(`üîå Creating new plugin: ${pluginName}`);
    
    const pluginDir = path.join(this.pluginsDir, pluginName);
    
    if (fs.existsSync(pluginDir)) {
      console.error(`‚ùå Plugin ${pluginName} already exists`);
      return false;
    }

    // Create plugin directory structure
    fs.mkdirSync(pluginDir, { recursive: true });
    fs.mkdirSync(path.join(pluginDir, 'backend'));
    fs.mkdirSync(path.join(pluginDir, 'frontend'));
    fs.mkdirSync(path.join(pluginDir, 'tests'));

    // Create plugin.yaml
    const pluginYaml = `name: ${pluginName}
version: 1.0.0
author: ${process.env.USER || 'Plugin Developer'}
description: Description for ${pluginName} plugin
license: MIT

# Plugin configuration
main: backend/index.js
frontend: frontend/index.js

# Required permissions
permissions:
  routes: false
  database: false
  filesystem: false
  network: false

# API endpoints this plugin provides
api:
  routes: []

# Dependencies
dependencies:
  node: ">=14.0.0"
  
# Plugin metadata
tags:
  - custom
  
# Plugin lifecycle hooks
hooks:
  install: true
  enable: true
  disable: true
  uninstall: true`;

    fs.writeFileSync(path.join(pluginDir, 'plugin.yaml'), pluginYaml);

    // Create backend/index.js
    const backendCode = `/**
 * ${pluginName} Plugin
 * Generated by Plugin CLI Tool
 */

class ${this.capitalize(this.camelCase(pluginName))}Plugin {
  constructor(context) {
    this.context = context;
    this.logger = context.logger;
    this.pluginName = context.pluginName;
  }

  // Lifecycle methods
  async onInstall() {
    this.logger.info(\`Plugin \${this.pluginName} installed\`);
  }

  async onEnable() {
    this.logger.info(\`Plugin \${this.pluginName} enabled\`);
  }

  async onDisable() {
    this.logger.info(\`Plugin \${this.pluginName} disabled\`);
  }

  async onUninstall() {
    this.logger.info(\`Plugin \${this.pluginName} uninstalled\`);
  }

  // Add your plugin methods here
}

module.exports = ${this.capitalize(this.camelCase(pluginName))}Plugin;`;

    fs.writeFileSync(path.join(pluginDir, 'backend', 'index.js'), backendCode);

    // Create README.md
    const readme = `# ${pluginName} Plugin

Description of your plugin functionality.

## Installation

\`\`\`bash
npm run plugin:install ${pluginName}
\`\`\`

## Usage

Describe how to use your plugin.

## Development

\`\`\`bash
# Test the plugin
npm run plugin:test ${pluginName}

# Validate plugin structure
npm run plugin:validate ${pluginName}
\`\`\``;

    fs.writeFileSync(path.join(pluginDir, 'README.md'), readme);

    console.log(`‚úÖ Plugin ${pluginName} created successfully!`);
    console.log(`üìÅ Location: ${pluginDir}`);
    console.log(`\nüöÄ Next steps:`);
    console.log(`   1. Edit ${pluginName}/plugin.yaml to configure your plugin`);
    console.log(`   2. Implement your plugin logic in ${pluginName}/backend/index.js`);
    console.log(`   3. Test with: npm run plugin:test ${pluginName}`);
    console.log(`   4. Install with: npm run plugin:install ${pluginName}`);

    return true;
  }

  // Install a plugin into the system
  async install(pluginPath) {
    console.log(`üì¶ Installing plugin from: ${pluginPath}`);
    
    try {
      // Load plugin metadata
      const metadataPath = path.join(pluginPath, 'plugin.yaml');
      if (!fs.existsSync(metadataPath)) {
        throw new Error('plugin.yaml not found');
      }

      const yaml = require('js-yaml');
      const metadata = yaml.load(fs.readFileSync(metadataPath, 'utf8'));

      // Check if plugin already exists
      const existingPlugin = await this.prisma.plugin.findUnique({
        where: { name: metadata.name }
      });

      if (existingPlugin) {
        console.log(`‚ö†Ô∏è  Plugin ${metadata.name} already installed`);
        return false;
      }

      // Create plugin record
      const plugin = await this.prisma.plugin.create({
        data: {
          name: metadata.name,
          version: metadata.version,
          author: metadata.author,
          description: metadata.description,
          permissions: metadata.permissions || {},
          autoUpdate: false,
          versionLocked: false,
          status: 'INACTIVE'
        }
      });

      console.log(`‚úÖ Plugin ${metadata.name} installed successfully`);
      console.log(`   ID: ${plugin.id}`);
      console.log(`   Version: ${plugin.version}`);
      console.log(`   Status: ${plugin.status}`);

      return true;

    } catch (error) {
      console.error(`‚ùå Failed to install plugin: ${error.message}`);
      return false;
    }
  }

  // List all plugins
  async list() {
    try {
      const plugins = await this.prisma.plugin.findMany({
        orderBy: { name: 'asc' }
      });

      if (plugins.length === 0) {
        console.log('üì¶ No plugins installed');
        return;
      }

      console.log(`\nüì¶ Installed Plugins (${plugins.length}):\n`);
      
      plugins.forEach(plugin => {
        const status = plugin.status === 'ACTIVE' ? 'üü¢' : 
                      plugin.status === 'INACTIVE' ? 'üî¥' : 
                      plugin.status === 'ERROR' ? '‚ö†Ô∏è' : 'üü°';
        
        console.log(`${status} ${plugin.name} v${plugin.version}`);
        console.log(`   Author: ${plugin.author}`);
        console.log(`   Status: ${plugin.status}`);
        if (plugin.description) {
          console.log(`   Description: ${plugin.description}`);
        }
        console.log('');
      });

    } catch (error) {
      console.error(`‚ùå Failed to list plugins: ${error.message}`);
    }
  }

  // Enable a plugin
  async enable(pluginName) {
    try {
      const plugin = await this.prisma.plugin.findUnique({
        where: { name: pluginName }
      });

      if (!plugin) {
        console.error(`‚ùå Plugin ${pluginName} not found`);
        return false;
      }

      if (plugin.status === 'ACTIVE') {
        console.log(`‚úÖ Plugin ${pluginName} is already active`);
        return true;
      }

      await this.prisma.plugin.update({
        where: { name: pluginName },
        data: { status: 'ACTIVE' }
      });

      console.log(`‚úÖ Plugin ${pluginName} enabled successfully`);
      return true;

    } catch (error) {
      console.error(`‚ùå Failed to enable plugin: ${error.message}`);
      return false;
    }
  }

  // Disable a plugin
  async disable(pluginName) {
    try {
      const plugin = await this.prisma.plugin.findUnique({
        where: { name: pluginName }
      });

      if (!plugin) {
        console.error(`‚ùå Plugin ${pluginName} not found`);
        return false;
      }

      if (plugin.status === 'INACTIVE') {
        console.log(`‚úÖ Plugin ${pluginName} is already inactive`);
        return true;
      }

      await this.prisma.plugin.update({
        where: { name: pluginName },
        data: { status: 'INACTIVE' }
      });

      console.log(`‚úÖ Plugin ${pluginName} disabled successfully`);
      return true;

    } catch (error) {
      console.error(`‚ùå Failed to disable plugin: ${error.message}`);
      return false;
    }
  }

  // Validate plugin structure
  validate(pluginPath) {
    console.log(`üîç Validating plugin: ${pluginPath}`);
    
    const errors = [];
    const warnings = [];

    // Check if directory exists
    if (!fs.existsSync(pluginPath)) {
      errors.push('Plugin directory does not exist');
      return { valid: false, errors, warnings };
    }

    // Check plugin.yaml
    const metadataPath = path.join(pluginPath, 'plugin.yaml');
    if (!fs.existsSync(metadataPath)) {
      errors.push('plugin.yaml not found');
    } else {
      try {
        const yaml = require('js-yaml');
        const metadata = yaml.load(fs.readFileSync(metadataPath, 'utf8'));
        
        if (!metadata.name) errors.push('Plugin name is required');
        if (!metadata.version) errors.push('Plugin version is required');
        if (!metadata.author) errors.push('Plugin author is required');
        if (!metadata.description) warnings.push('Plugin description is recommended');
        
      } catch (err) {
        errors.push(`Invalid plugin.yaml: ${err.message}`);
      }
    }

    // Check backend/index.js
    const backendPath = path.join(pluginPath, 'backend', 'index.js');
    if (!fs.existsSync(backendPath)) {
      errors.push('backend/index.js not found');
    }

    // Check README.md
    const readmePath = path.join(pluginPath, 'README.md');
    if (!fs.existsSync(readmePath)) {
      warnings.push('README.md not found');
    }

    const valid = errors.length === 0;

    if (valid) {
      console.log('‚úÖ Plugin validation passed');
    } else {
      console.log('‚ùå Plugin validation failed');
    }

    if (errors.length > 0) {
      console.log('\n‚ùå Errors:');
      errors.forEach(error => console.log(`   - ${error}`));
    }

    if (warnings.length > 0) {
      console.log('\n‚ö†Ô∏è  Warnings:');
      warnings.forEach(warning => console.log(`   - ${warning}`));
    }

    return { valid, errors, warnings };
  }

  // Helper methods
  camelCase(str) {
    return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  }

  capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  async cleanup() {
    await this.prisma.$disconnect();
  }
}

// CLI Interface
async function main() {
  const args = process.argv.slice(2);
  const command = args[0];
  // Pass the Prisma client to the CLI constructor if available
  const cli = new PluginCLI(global.mockedPrismaClient || null);
  
  await cli.init();

  try {
    switch (command) {
      case 'create':
        if (!args[1]) {
          console.error('‚ùå Plugin name required: npm run plugin:create <name>');
          process.exit(1);
        }
        await cli.create(args[1]);
        break;

      case 'install':
        if (!args[1]) {
          console.error('‚ùå Plugin path required: npm run plugin:install <path>');
          process.exit(1);
        }
        await cli.install(args[1]);
        break;

      case 'list':
        await cli.list();
        break;

      case 'enable':
        if (!args[1]) {
          console.error('‚ùå Plugin name required: npm run plugin:enable <name>');
          process.exit(1);
        }
        await cli.enable(args[1]);
        break;

      case 'disable':
        if (!args[1]) {
          console.error('‚ùå Plugin name required: npm run plugin:disable <name>');
          process.exit(1);
        }
        await cli.disable(args[1]);
        break;

      case 'validate':
        if (!args[1]) {
          console.error('‚ùå Plugin path required: npm run plugin:validate <path>');
          process.exit(1);
        }
        cli.validate(args[1]);
        break;

      default:
        console.log(`üîå Plugin Development CLI

Usage:
  npm run plugin:create <name>     Create a new plugin
  npm run plugin:install <path>    Install a plugin
  npm run plugin:list              List all plugins
  npm run plugin:enable <name>     Enable a plugin
  npm run plugin:disable <name>    Disable a plugin
  npm run plugin:validate <path>   Validate plugin structure

Examples:
  npm run plugin:create my-awesome-plugin
  npm run plugin:install ./plugins/my-plugin
  npm run plugin:validate ./sample-plugins/hello-world`);
    }
  } catch (error) {
    console.error(`‚ùå Command failed: ${error.message}`);
    process.exit(1);
  } finally {
    await cli.cleanup();
  }
}

if (require.main === module) {
  main();
}

module.exports = PluginCLI;

import { describe, test, expect, beforeAll, afterAll, beforeEach, afterEach } from '@jest/globals';
import request from 'supertest';
import path from 'path';
import fs from 'fs';
import { execSync } from 'child_process';
import { createApp } from '../src/app';

// Test constants
const TEST_PLUGIN_NAME = 'test-plugin-system';
const TEST_PLUGIN_PATH = path.join(__dirname, `../sample-plugins/${TEST_PLUGIN_NAME}`);
const CLI_SCRIPT = path.join(__dirname, '../scripts/plugin-tools/cli.js');

// Helper functions for test setup
const createTestPlugin = (name: string, config: Record<string, any> = {}) => {
  const pluginPath = path.join(__dirname, '../sample-plugins/' + name);
  
  if (!fs.existsSync(pluginPath)) {
    fs.mkdirSync(pluginPath, { recursive: true });
  }

  const defaultConfig = {
    name,
    version: '1.0.0',
    author: 'Test Author',
    description: 'Test plugin',
    main: 'plugin.js',
    permissions: {
      routes: false,
      database: false,
      filesystem: false,
      network: false
    }
  };

  const pluginConfig = { ...defaultConfig, ...config };
  
  const yamlContent = 'name: ' + pluginConfig.name + '\n' +
    'version: ' + pluginConfig.version + '\n' +
    'author: ' + pluginConfig.author + '\n' +
    'description: ' + pluginConfig.description + '\n' +
    'main: ' + pluginConfig.main + '\n' +
    'permissions:\n' +
    '  routes: ' + pluginConfig.permissions.routes + '\n' +
    '  database: ' + pluginConfig.permissions.database + '\n' +
    '  filesystem: ' + pluginConfig.permissions.filesystem + '\n' +
    '  network: ' + pluginConfig.permissions.network;
  
  fs.writeFileSync(path.join(pluginPath, 'plugin.yaml'), yamlContent);

  // Create plugin.js content with proper escaping
  const pluginJsContent = 'const { PluginBase } = require(\'../../sdk/PluginBase\');\n' +
    '\n' +
    'class TestPlugin extends PluginBase {\n' +
    '  constructor(context) {\n' +
    '    super(context);\n' +
    '    this.name = \'' + name + '\';\n' +
    '    this.version = \'' + pluginConfig.version + '\';\n' +
    '  }\n' +
    '\n' +
    '  async install() {\n' +
    '    this.log(\'Installing ' + name + '...\');\n' +
    '    return { success: true };\n' +
    '  }\n' +
    '\n' +
    '  async enable() {\n' +
    '    this.log(\'Enabling ' + name + '...\');\n' +
    '    return { success: true };\n' +
    '  }\n' +
    '\n' +
    '  async disable() {\n' +
    '    this.log(\'Disabling ' + name + '...\');\n' +
    '    return { success: true };\n' +
    '  }\n' +
    '\n' +
    '  async uninstall() {\n' +
    '    this.log(\'Uninstalling ' + name + '...\');\n' +
    '    return { success: true };\n' +
    '  }\n' +
    '}\n' +
    '\n' +
    'module.exports = TestPlugin;';
  
  fs.writeFileSync(path.join(pluginPath, 'plugin.js'), pluginJsContent);
  
  // Create backend directory and index.js
  const backendPath = path.join(pluginPath, 'backend');
  if (!fs.existsSync(backendPath)) {
    fs.mkdirSync(backendPath, { recursive: true });
  }
  
  fs.writeFileSync(path.join(backendPath, 'index.js'), `
// Test plugin backend
console.log('Test plugin backend loaded');
  `);

  return pluginPath;
}

async function cleanupTestPlugin(name: string) {
  // Clean up any existing test plugins
  const existingPlugins = [
    'test-plugin-system',
    'test-plugin',
    'test-api-plugin',
    'test-plugin-2'
  ];
  
  for (const existingName of existingPlugins) {
    try {
      // Use PluginManager to uninstall the plugin
      const { PluginManager } = require('../src/services/PluginManager.full');
      await PluginManager.uninstallPlugin(existingName);
    } catch {
      // Ignore cleanup errors
    }
  }

  const pluginPath = path.join(__dirname, '../plugins/' + name);
  
  try {
    // Use PluginManager to uninstall the plugin
    const { PluginManager } = require('../src/services/PluginManager.full');
    await PluginManager.uninstallPlugin(name);
  } catch {
    // Plugin might not be installed
  }

  try {
    fs.rmSync(pluginPath, { recursive: true, force: true });
  } catch {
    // Directory might not exist
  }
}

describe('Plugin System Integration Tests', () => {
  let app: any;
  let server: any;
  let testPluginCreated = false;

  beforeAll(async () => {
    // Initialize DatabaseService
    const { DatabaseService } = await import('../src/services/database');
    await DatabaseService.initialize();
  });
  
  // Set up test app at top level like other tests
  app = createApp();
  
  beforeAll(async () => {
    // Start server on a random port
    server = app.listen(0);
    
    // Clean up any existing test plugins
    try {
      cleanupTestPlugin(TEST_PLUGIN_NAME);
    } catch (error) {
      // Ignore cleanup errors
    }
  });

  afterAll(async () => {
    // Clean up server
    if (server) {
      server.close();
    }

    // Clean up file system
    try {
      cleanupTestPlugin(TEST_PLUGIN_NAME);
    } catch (error) {
      // Ignore cleanup errors
    }
  });

  describe('CLI Tools', () => {
    test('should create a new plugin', () => {
      expect(() => {
        execSync(`node ${CLI_SCRIPT} create ${TEST_PLUGIN_NAME}`, { 
          stdio: 'inherit',
          cwd: path.join(__dirname, '../sample-plugins')
        });
        testPluginCreated = true;
      }).not.toThrow();

      // Verify plugin directory was created
      expect(fs.existsSync(TEST_PLUGIN_PATH)).toBe(true);
      
      // Verify plugin files were created
      expect(fs.existsSync(path.join(TEST_PLUGIN_PATH, 'plugin.yaml'))).toBe(true);
      expect(fs.existsSync(path.join(TEST_PLUGIN_PATH, 'plugin.js'))).toBe(true);
      expect(fs.existsSync(path.join(TEST_PLUGIN_PATH, 'backend'))).toBe(true);
      expect(fs.existsSync(path.join(TEST_PLUGIN_PATH, 'backend', 'index.js'))).toBe(true);
    });

    test('should install a plugin via CLI', () => {
      expect(() => {
        execSync(`node ${CLI_SCRIPT} install ${TEST_PLUGIN_NAME}`, { 
          stdio: 'inherit',
          cwd: path.join(__dirname, '..')
        });
      }).not.toThrow();
    });

    test('should list installed plugins via CLI', () => {
      const output = execSync(`node ${CLI_SCRIPT} list`, { 
        cwd: path.join(__dirname, '..')
      }).toString();
      
      expect(output).toContain(TEST_PLUGIN_NAME);
    });

    test('should enable a plugin via CLI', () => {
      expect(() => {
        execSync(`node ${CLI_SCRIPT} enable ${TEST_PLUGIN_NAME}`, { 
          stdio: 'inherit',
          cwd: path.join(__dirname, '..')
        });
      }).not.toThrow();
    });

    test('should disable a plugin via CLI', () => {
      expect(() => {
        execSync(`node ${CLI_SCRIPT} disable ${TEST_PLUGIN_NAME}`, { 
          stdio: 'inherit',
          cwd: path.join(__dirname, '..')
        });
      }).not.toThrow();
    });

    test('should uninstall a plugin via CLI', () => {
      expect(() => {
        execSync(`node ${CLI_SCRIPT} uninstall ${TEST_PLUGIN_NAME}`, { 
          stdio: 'inherit',
          cwd: path.join(__dirname, '..')
        });
      }).not.toThrow();
    });
  });

  describe('Plugin Manager Service', () => {
    beforeEach(async () => {
      // Clean up any existing test plugins
      try {
        await cleanupTestPlugin(TEST_PLUGIN_NAME);
      } catch (error) {
        // Ignore cleanup errors
      }
    });

    afterEach(async () => {
      // Clean up any existing test plugins
      try {
        await cleanupTestPlugin(TEST_PLUGIN_NAME);
      } catch (error) {
        // Ignore cleanup errors
      }
    });

    test('should install plugin using static method', async () => {
      // Create test plugin
      createTestPlugin(TEST_PLUGIN_NAME);
      
      // Install the plugin using PluginManager directly
      const { PluginManager } = await import('../src/services/PluginManager.full');
      const { DatabaseService } = await import('../src/services/database');
      const prisma = DatabaseService.getInstance();
      
      const result = await PluginManager.installPlugin(TEST_PLUGIN_PATH);
      expect(result.success).toBe(true);
      
      // Verify plugin was installed in database
      const plugin = await prisma.plugin.findUnique({
        where: { name: TEST_PLUGIN_NAME }
      });
      expect(plugin).not.toBeNull();
      expect(plugin?.name).toBe(TEST_PLUGIN_NAME);
      expect(plugin?.status).toBe('installed');
    });

    test('should enable plugin using static method', async () => {
      // Create and install test plugin
      createTestPlugin(TEST_PLUGIN_NAME);
      
      const { PluginManager } = await import('../src/services/PluginManager.full');
      const { DatabaseService } = await import('../src/services/database');
      const prisma = DatabaseService.getInstance();
      
      await PluginManager.installPlugin(TEST_PLUGIN_PATH);
      
      const result = await PluginManager.enablePlugin(TEST_PLUGIN_NAME);
      expect(result.success).toBe(true);
      
      // Verify plugin was enabled in database
      const plugin = await prisma.plugin.findUnique({
        where: { name: TEST_PLUGIN_NAME }
      });
      expect(plugin).not.toBeNull();
      expect(plugin?.status).toBe('enabled');
    });

    test('should disable plugin using static method', async () => {
      // Create, install, and enable test plugin
      createTestPlugin(TEST_PLUGIN_NAME);
      
      const { PluginManager } = await import('../src/services/PluginManager.full');
      const { DatabaseService } = await import('../src/services/database');
      const prisma = DatabaseService.getInstance();
      
      await PluginManager.installPlugin(TEST_PLUGIN_PATH);
      await PluginManager.enablePlugin(TEST_PLUGIN_NAME);
      
      const result = await PluginManager.disablePlugin(TEST_PLUGIN_NAME);
      expect(result.success).toBe(true);
      
      // Verify plugin was disabled in database
      const plugin = await prisma.plugin.findUnique({
        where: { name: TEST_PLUGIN_NAME }
      });
      expect(plugin).not.toBeNull();
      expect(plugin?.status).toBe('disabled');
    });

    test('should uninstall plugin using static method', async () => {
      // Create, install, and enable test plugin
      createTestPlugin(TEST_PLUGIN_NAME);
      
      const { PluginManager } = await import('../src/services/PluginManager.full');
      const { DatabaseService } = await import('../src/services/database');
      const prisma = DatabaseService.getInstance();
      
      await PluginManager.installPlugin(TEST_PLUGIN_PATH);
      await PluginManager.enablePlugin(TEST_PLUGIN_NAME);
      
      const result = await PluginManager.uninstallPlugin(TEST_PLUGIN_NAME);
      expect(result.success).toBe(true);
      
      // Verify plugin was uninstalled from database
      const plugin = await prisma.plugin.findUnique({
        where: { name: TEST_PLUGIN_NAME }
      });
      expect(plugin).toBeNull();
    });

    test('should list installed plugins using static method', async () => {
      // Create and install test plugin
      createTestPlugin(TEST_PLUGIN_NAME);
      
      const { PluginManager } = await import('../src/services/PluginManager.full');
      const { DatabaseService } = await import('../src/services/database');
      const prisma = DatabaseService.getInstance();
      
      await PluginManager.installPlugin(TEST_PLUGIN_PATH);
      
      // Get all plugins from database directly since listPlugins doesn't exist
      const { DatabaseService: DatabaseService1 } = await import('../src/services/database');
      const prisma1 = DatabaseService1.getInstance();
      const plugins = await prisma1.plugin.findMany();
      expect(plugins).not.toBeNull();
      expect(Array.isArray(plugins)).toBe(true);
      expect(plugins.length).toBeGreaterThanOrEqual(1);
      
      const testPlugin = plugins.find((p: any) => p.name === TEST_PLUGIN_NAME);
      expect(testPlugin).not.toBeNull();
      expect(testPlugin?.name).toBe(TEST_PLUGIN_NAME);
      expect(testPlugin?.status).toBe('installed');
    });
  });

  describe('Database Integration', () => {
    beforeEach(() => {
      // Clean up any existing test plugins
      try {
        cleanupTestPlugin(TEST_PLUGIN_NAME);
      } catch (error) {
        // Ignore cleanup errors
      }
    });

    afterEach(() => {
      // Clean up any existing test plugins
      try {
        cleanupTestPlugin(TEST_PLUGIN_NAME);
      } catch (error) {
        // Ignore cleanup errors
      }
    });

    test('should create plugin entry in database', async () => {
      // Create test plugin
      createTestPlugin(TEST_PLUGIN_NAME);
      
      const { PluginManager } = await import('../src/services/PluginManager.full');
      const { DatabaseService } = await import('../src/services/database');
      const prisma = DatabaseService.getInstance();
      
      await PluginManager.installPlugin(TEST_PLUGIN_PATH);
      
      const plugin = await prisma.plugin.findUnique({
        where: { name: TEST_PLUGIN_NAME }
      });
      
      expect(plugin).not.toBeNull();
      expect(plugin?.name).toBe(TEST_PLUGIN_NAME);
      expect(plugin?.status).toBe('installed');
      expect(plugin?.version).toBe('1.0.0');
      expect(plugin?.author).toBe('Test Author');
      expect(plugin?.description).toBe('Test plugin');
    });

    test('should update plugin status in database', async () => {
      // Create and install test plugin
      createTestPlugin(TEST_PLUGIN_NAME);
      
      const { PluginManager } = await import('../src/services/PluginManager.full');
      const { DatabaseService } = await import('../src/services/database');
      const prisma = DatabaseService.getInstance();
      
      await PluginManager.installPlugin(TEST_PLUGIN_PATH);
      await PluginManager.enablePlugin(TEST_PLUGIN_NAME);
      
      let plugin = await prisma.plugin.findUnique({
        where: { name: TEST_PLUGIN_NAME }
      });
      
      expect(plugin).not.toBeNull();
      expect(plugin?.status).toBe('enabled');
      
      await PluginManager.disablePlugin(TEST_PLUGIN_NAME);
      
      plugin = await prisma.plugin.findUnique({
        where: { name: TEST_PLUGIN_NAME }
      });
      
      expect(plugin).not.toBeNull();
      expect(plugin?.status).toBe('disabled');
    });
  });

  describe('Error Handling', () => {
    beforeEach(() => {
      // Clean up any existing test plugins
      try {
        cleanupTestPlugin(TEST_PLUGIN_NAME);
      } catch (error) {
        // Ignore cleanup errors
      }
    });

    afterEach(() => {
      // Clean up any existing test plugins
      try {
        cleanupTestPlugin(TEST_PLUGIN_NAME);
      } catch (error) {
        // Ignore cleanup errors
      }
    });

    test('should handle missing plugin.yaml', async () => {
      // Create plugin directory without plugin.yaml
      const pluginPath = path.join(__dirname, '../sample-plugins/invalid-plugin');
      if (!fs.existsSync(pluginPath)) {
        fs.mkdirSync(pluginPath, { recursive: true });
      }
      
      const { PluginManager } = await import('../src/services/PluginManager.full');
      
      await expect(PluginManager.installPlugin(pluginPath)).rejects.toThrow();
      
      // Clean up
      try {
        fs.rmSync(pluginPath, { recursive: true, force: true });
      } catch {
        // Ignore cleanup errors
      }
    });

    test('should handle plugin not found when enabling', async () => {
      const { PluginManager } = await import('../src/services/PluginManager.full');
      
      await expect(PluginManager.enablePlugin('non-existent-plugin')).rejects.toThrow();
    });
  });

  describe('Plugin Lifecycle', () => {
    beforeEach(() => {
      // Clean up any existing test plugins
      try {
        cleanupTestPlugin(TEST_PLUGIN_NAME);
      } catch (error) {
        // Ignore cleanup errors
      }
    });

    afterEach(() => {
      // Clean up any existing test plugins
      try {
        cleanupTestPlugin(TEST_PLUGIN_NAME);
      } catch (error) {
        // Ignore cleanup errors
      }
    });

    test('should complete full plugin lifecycle', async () => {
      // Create test plugin
      createTestPlugin(TEST_PLUGIN_NAME);
      
      const { PluginManager } = await import('../src/services/PluginManager.full');
      const { DatabaseService } = await import('../src/services/database');
      const prisma = DatabaseService.getInstance();
      
      // Install
      let result = await PluginManager.installPlugin(TEST_PLUGIN_PATH);
      expect(result.success).toBe(true);
      
      let plugin = await prisma.plugin.findUnique({
        where: { name: TEST_PLUGIN_NAME }
      });
      expect(plugin).not.toBeNull();
      expect(plugin?.status).toBe('installed');
      
      // Enable
      const enableResult = await PluginManager.enablePlugin(TEST_PLUGIN_NAME);
      expect(enableResult.success).toBe(true);
      
      plugin = await prisma.plugin.findUnique({
        where: { name: TEST_PLUGIN_NAME }
      });
      expect(plugin).not.toBeNull();
      expect(plugin?.status).toBe('enabled');
      
      // Disable
      const disableResult = await PluginManager.disablePlugin(TEST_PLUGIN_NAME);
      expect(disableResult.success).toBe(true);
      
      plugin = await prisma.plugin.findUnique({
        where: { name: TEST_PLUGIN_NAME }
      });
      expect(plugin).not.toBeNull();
      expect(plugin?.status).toBe('disabled');
      
      // Uninstall
      const uninstallResult = await PluginManager.uninstallPlugin(TEST_PLUGIN_NAME);
      expect(uninstallResult.success).toBe(true);
      
      plugin = await prisma.plugin.findUnique({
        where: { name: TEST_PLUGIN_NAME }
      });
      expect(plugin).toBeNull();
    });
  });

  describe('API Endpoints', () => {
    beforeEach(async () => {
      // Clean up any existing test plugins
      try {
        cleanupTestPlugin(TEST_PLUGIN_NAME);
      } catch (error) {
        // Ignore cleanup errors
      }
      
      // Create and install test plugin
      createTestPlugin(TEST_PLUGIN_NAME);
      
      const { PluginManager } = await import('../src/services/PluginManager.full');
      await PluginManager.installPlugin(TEST_PLUGIN_PATH);
    });

    afterEach(() => {
      // Clean up any existing test plugins
      try {
        cleanupTestPlugin(TEST_PLUGIN_NAME);
      } catch (error) {
        // Ignore cleanup errors
      }
    });

    test('should get plugin info', async () => {
      const response = await request(app)
        .get(`/api/plugins/${TEST_PLUGIN_NAME}`)
        .expect(200);
      
      expect(response.body).toHaveProperty('name', TEST_PLUGIN_NAME);
      expect(response.body).toHaveProperty('status', 'installed');
    });

    test('should list all plugins', async () => {
      const response = await request(app)
        .get('/api/plugins')
        .expect(200);
      
      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.length).toBeGreaterThanOrEqual(1);
      
      const testPlugin = response.body.find((p: any) => p.name === TEST_PLUGIN_NAME);
      expect(testPlugin).not.toBeNull();
      expect(testPlugin).toHaveProperty('name', TEST_PLUGIN_NAME);
      expect(testPlugin).toHaveProperty('status', 'installed');
    });

    test('should enable plugin', async () => {
      const response = await request(app)
        .post(`/api/plugins/${TEST_PLUGIN_NAME}/enable`)
        .expect(200);
      
      expect(response.body).toHaveProperty('success', true);
      
      // Verify plugin was enabled
      const { DatabaseService } = await import('../src/services/database');
      const prisma = DatabaseService.getInstance();
      const plugin = await prisma.plugin.findUnique({
        where: { name: TEST_PLUGIN_NAME }
      });
      expect(plugin).not.toBeNull();
      expect(plugin?.status).toBe('enabled');
    });

    test('should disable plugin', async () => {
      // First enable the plugin
      const { PluginManager } = await import('../src/services/PluginManager.full');
      await PluginManager.enablePlugin(TEST_PLUGIN_NAME);
      
      const response = await request(app)
        .post(`/api/plugins/${TEST_PLUGIN_NAME}/disable`)
        .expect(200);
      
      expect(response.body).toHaveProperty('success', true);
      
      // Verify plugin was disabled
      const { DatabaseService } = await import('../src/services/database');
      const prisma = DatabaseService.getInstance();
      const plugin = await prisma.plugin.findUnique({
        where: { name: TEST_PLUGIN_NAME }
      });
      expect(plugin).not.toBeNull();
      expect(plugin?.status).toBe('disabled');
    });

    test('should uninstall plugin', async () => {
      const response = await request(app)
        .delete(`/api/plugins/${TEST_PLUGIN_NAME}`)
        .expect(200);
      
      expect(response.body).toHaveProperty('success', true);
      
      // Verify plugin was uninstalled
      const { DatabaseService } = await import('../src/services/database');
      const prisma = DatabaseService.getInstance();
      const plugin = await prisma.plugin.findUnique({
        where: { name: TEST_PLUGIN_NAME }
      });
      expect(plugin).toBeNull();
    });
  });

  describe('Performance Tests', () => {
    beforeEach(() => {
      // Clean up any existing test plugins
      try {
        cleanupTestPlugin(TEST_PLUGIN_NAME);
      } catch (error) {
        // Ignore cleanup errors
      }
    });

    afterEach(() => {
      // Clean up any existing test plugins
      try {
        cleanupTestPlugin(TEST_PLUGIN_NAME);
      } catch (error) {
        // Ignore cleanup errors
      }
    });

    test('should handle multiple concurrent plugin operations', async () => {
      // Create multiple test plugins
      const pluginNames = ['test-plugin-1', 'test-plugin-2', 'test-plugin-3'];
      
      for (const name of pluginNames) {
        createTestPlugin(name);
      }
      
      const { PluginManager } = await import('../src/services/PluginManager.full');
      
      // Install all plugins concurrently
      const installPromises = pluginNames.map(name => 
        PluginManager.installPlugin(path.join(__dirname, '../sample-plugins/' + name))
      );
      
      const installResults = await Promise.all(installPromises);
      installResults.forEach(result => {
        expect(result.success).toBe(true);
      });
      
      // Enable all plugins concurrently
      const enablePromises = pluginNames.map(name => 
        PluginManager.enablePlugin(name)
      );
      
      const enableResults = await Promise.all(enablePromises);
      enableResults.forEach(result => {
        expect(result.success).toBe(true);
      });
      
      // Disable all plugins concurrently
      const disablePromises = pluginNames.map(name => 
        PluginManager.disablePlugin(name)
      );
      
      const disableResults = await Promise.all(disablePromises);
      disableResults.forEach(result => {
        expect(result.success).toBe(true);
      });
      
      // Uninstall all plugins concurrently
      const uninstallPromises = pluginNames.map(name => 
        PluginManager.uninstallPlugin(name)
      );
      
      const uninstallResults = await Promise.all(uninstallPromises);
      uninstallResults.forEach(result => {
        expect(result.success).toBe(true);
      });
      
      // Clean up
      for (const name of pluginNames) {
        try {
          cleanupTestPlugin(name);
        } catch {
          // Ignore cleanup errors
        }
      }
    });
  });

  describe('createTestPlugin', () => {
    it('should create plugin directory', async () => {
      const pluginPath = createTestPlugin('test-plugin');
      expect(fs.existsSync(pluginPath)).toBe(true);
    });
    
    it('should create plugin.yaml', async () => {
      const pluginPath = createTestPlugin('test-plugin');
      expect(fs.existsSync(path.join(pluginPath, 'plugin.yaml'))).toBe(true);
    });
    
    it('should create plugin.js', async () => {
      const pluginPath = createTestPlugin('test-plugin');
      expect(fs.existsSync(path.join(pluginPath, 'plugin.js'))).toBe(true);
    });
    
    it('should create backend directory', async () => {
      const pluginPath = createTestPlugin('test-plugin');
      expect(fs.existsSync(path.join(pluginPath, 'backend'))).toBe(true);
    });
    
    it('should create backend index.js', async () => {
      const pluginPath = createTestPlugin('test-plugin');
      expect(fs.existsSync(path.join(pluginPath, 'backend', 'index.js'))).toBe(true);
    });
    
    it('should cleanup plugin directory', async () => {
      const pluginPath = createTestPlugin('test-plugin');
      expect(fs.existsSync(pluginPath)).toBe(true);
      
      cleanupTestPlugin('test-plugin');
      expect(fs.existsSync(pluginPath)).toBe(false);
    });
  });
});
